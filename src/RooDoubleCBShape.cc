/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "../interface/RooDoubleCBShape.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

//ClassImp(RooDoubleCBShape) 

 RooDoubleCBShape::RooDoubleCBShape(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _m0,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha1,
                        RooAbsReal& _n1,
                        RooAbsReal& _alpha2,
                        RooAbsReal& _n2) :
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   alpha1("alpha1","alpha1",this,_alpha1),
   n1("n1","n1",this,_n1),
   alpha2("alpha2","alpha2",this,_alpha2),
   n2("n2","n2",this,_n2)
 { 
 } 


 RooDoubleCBShape::RooDoubleCBShape(const RooDoubleCBShape& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   alpha1("alpha1",this,other.alpha1),
   n1("n1",this,other.n1),
   alpha2("alpha2",this,other.alpha2),
   n2("n2",this,other.n2)
 { 
 } 



 Double_t RooDoubleCBShape::evaluate() const 
 { 
   
  Double_t t = (m-m0)/sigma;
  
  Double_t absAlpha1 = fabs((Double_t)alpha1);
  Double_t absAlpha2 = fabs((Double_t)alpha2);
  
  if (t >= -absAlpha1 && t<=absAlpha2 ) { 

    return exp(-0.5*t*t);

  } else if( t<-absAlpha1 ) { 
    Double_t a =  TMath::Power(n1/absAlpha1,n1)*exp(-0.5*absAlpha1*absAlpha1);
    Double_t b= n1/absAlpha1 - absAlpha1; 
  
    return a*TMath::Power(b - t, -n1);

  } else { // t>absAlpha2

    Double_t a =  TMath::Power(n2/absAlpha2,n2)*exp(-0.5*absAlpha2*absAlpha2);
    Double_t b= n2/absAlpha2 - absAlpha2; 
  
    return a*TMath::Power(b + t, -n2);
  } 

 }
